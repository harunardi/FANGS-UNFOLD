\label{ch:simulations}

The previous chapter explained that the history of the neutron noise method began as part of the experimental diagnostics methods performed in a nuclear reactor. Seeing the success of the technique, methods to solve the neutron noise computationally have also been developed in recent year \cite{demaziereCORTEXProjectImproving2020}. To perform reactor diagnostics using neutron noise analysis computationally, the tool must have the capability to perform not only neutron noise calculations, but also forward flux calculations, and also generate the Green’s function matrix. The forward flux is part of the source term in the neutron noise equation, which will be shown in the next section. The Green’s function is used as part of the neutron noise unfolding method \cite{demaziereIdentificationLocalizationAbsorbers2005}. Numerous efforts have been made to solve the neutron noise method computationally. Several examples of tools have been mentioned in the previous chapter. 

In this dissertation, a computational tool for neutron noise analysis is developed to address the gaps in the existing literature. Tools such as CORE SIM+ \cite{mylonakisCORESIMFlexible2021} can perform forward, adjoint, and noise calculations, as well as generate the Green’s function matrix. However, it lacks the ability for hexagonal or triangular geometries. Another tool, such as FEMFFUSION \cite{vidal-ferrandizFEMFFUSIONFiniteElement2023}, can perform forward, adjoint, and noise calculations for rectangular and triangular geometries using a finite element mesh, but lacks the ability to generate the Green’s function matrix. The tool developed in this dissertation can perform forward, adjoint, and noise calculations, as well as generate the Green’s function matrix for rectangular and triangular geometries. The tool relies on a multigroup diffusion equation for energy and angular treatment, and a box-scheme finite difference for the spatial discretization. The tool is available in \href{https://github.com/harunardi/FANGS-UNFOLD}{GitHub} for future references.

The structure of this chapter is as follows. First, we review the neutron noise equation that has been derived from the previous chapter. This includes the forward and adjoint equations, the inputs, and the outputs for each equation. Then, we focus on the spatial discretization method using box-scheme finite difference and how it is applied to 2D, 3D, rectangular, and triangular geometries for each equation. We also explain the boundary conditions that can be used in the tool. Lastly, we provide some case examples that cover forward, adjoint, and neutron noise calculations and how it compares to other simulations or analytical solutions.

%The neutron 
%\section{Spatial Discretization for Rectangular Geometries}
%\label{sec:rectangular_discretization}
%For the rectangular geometries, the system is divided into uniform meshes using rectilinear %grid. The size of the grid is an input for the user to adjust. As seen in Figure \ref%{fig:rect_discretize}, the discretization is uniform with $dx$ and $dy$ defined by the user. 
%\begin{figure}[h]
%        \centering
%        \includegraphics[width=0.6\textwidth]{figures/rect_discretize.png}
%        \caption{2D rectangular discretization}
%        \label{fig:rect_discretize}
%\end{figure}
%
%Equation \ref{eq:freq_4} are discretized and averaged over each mesh of the grid using box %scheme finite difference. The box scheme finite difference is one of the finite difference %method that uses a box-shaped control volume for discretization. The method is using center %point of the mesh as reference of the discretization. The method still relies on Taylor %expansion to obtain the discretization of the derivatives. To obtain the expression of the %discretized neutron noise equation, we integrate Equation \ref{eq:freq_4} over $x \in [x_{i - %\frac{1}{2}}, x_{i + \frac{1}{2}}]$ and $y \in [y_{i - \frac{1}{2}}, y_{i + \frac{1}{2}}]$.
%The integration results for generic reaction rates can defined as follow:
%\begin{equation}
%        \int_{x_{i - \frac{1}{2}}}^{x_{i + \frac{1}{2}}} \int_{y_{i - \frac{1}{2}}}^{y_{i + \frac%{1}{2}}} \Sigma_{g}(\textbf{r}, \omega) \phi_{g}(\textbf{r}, \omega) dx dy = \Sigma_{g,j,%i}(\omega) \phi_{g,j,i}(\omega) \Delta x \Delta y
%\end{equation}
%where $g$ is index for neutron energy group and $\Delta x \Delta y$ is the size of the mesh $n$. %The discretization of diffusion term depends on which axis of interest. The diffusion term in %x-direction is defined as follows.
%\begin{equation}
%        \begin{aligned}
%                & - \int_{x_{i - \frac{1}{2}}}^{x_{i + \frac{1}{2}}} \int_{y_{i - \frac{1}{2}}}^%{y_{i + \frac{1}{2}}} \nabla D_g(\textbf{r}) \nabla \delta \phi_g(\textbf{r}, %\omega) dx dy \\
%                &= - D_{g,j,i} \biggl( \frac{d}{dx} \delta \phi_{j,i + \frac{1}{2}}^- - \frac{d}%{dx} \delta \phi_{j,i - \frac{1}{2}}^+ \biggr) \Delta y\\
%                &= \frac{D_{g,j,i} \Delta y}{\Delta x} \biggl( -\frac{2 D_{g,j,i-1}}{D_{g,j,i-1} %+ D_{g,j,i}} \delta \phi_{g,j,i-1} + \biggl( \frac{2 D_{g,j,i+1}}{D_{g,j,i+1} + %D_{g,j,i}} + \frac{2 D_{g,j,i-1}}{D_{g,j,i-1} + D_{g,j,i}} \biggr) \delta \phi_%{g,j,i} \\
%                &  -\frac{2 D_{g,j,i+1}}{D_{g,j,i+1} + D_{g,j,i}} \delta \phi_{g,j,i+1} \biggr)
%        \end{aligned}
%\end{equation}
%Similar process is done for the y-direction.
%
%The boundary conditions used in this cases are mainly vacuum boundary conditions. However, the %code is able to solve vacuum boundary conditions, reflective boundary conditions, and zero flux %boundary conditions. The vacuum boundary condition is defined as follow,
%\begin{equation}
%        j_- = \frac{\phi(\textbf{r}_b)}{2} - D(\textbf{r}_b) \nabla \phi(\textbf{r}_b) = 0
%\end{equation}
%The reflective boundary conditions is defined as follow,
%\begin{equation}
%        \begin{aligned}
%                j_+  &= j_-\\
%                \frac{\phi(\textbf{r}_b)}{2} + D(\textbf{r}_b) \nabla \phi(\textbf{r}_b) &= \frac%{\phi(\textbf{r}_b)}{2} - D(\textbf{r}_b) \nabla \phi(\textbf{r}_b)
%        \end{aligned}
%\end{equation}
%Then the zero flux boundary condition is defined as follows,
%\begin{equation}
%        \phi(\textbf{r}_b) = 0
%\end{equation}
%
%\section{Spatial Discretization for Hexagonal Geometries}
%\label{sec:hexagonal_discretization}
%For the hexagonal geometries, the system 
%
%\section{Simulated Cases for Verification Purposes}
%\label{sec:simulated_vandv}
%
%\subsection{2D C3 Benchmark}
%Forward, Noise, ZPRTF, comparison
%
%The C3 reactor benchmark is a case for heterogeneous system. It is based on the C3 benchmark on %deterministic transport calculations \cite{cavarecBenchmarkCalculationsPower1994} and it is %perturbed by introducing a localized neutron noise source. The system configuration is given in %Figure \ref{fig:C3_configuration}. It consists of two UO2 fuel assemblies (at North-West and %South-East positions) and two MOX fuel assemblies (at North-East and South-West positions). The %size of each fuel assembly is 21.42 cm x 21.42 cm. The dark blue squares in the illustration are %guide tubes; the ones in the center of the fuel assemblies contain fission chambers. Reflective %boundary conditions are imposed. The perturbation is a fluctuation of 5\% of the fast and %thermal neutron capture cross-sections in the fuel cell (16,19) identified with a red square in %Figure \ref{fig:C3_configuration}.
%\begin{figure}[h]
%        \centering
%        \includegraphics[width=0.6\textwidth]{figures/C3_configuration.png}
%        \caption{Configuration of C3 Benchmark (taken from \cite%{mylonakisNeutronNoiseSimulations2019})}
%        \label{fig:C3_configuration}
%\end{figure}
%
%For this simulation, CORE SIM+ results using finite difference and discrete ordinate S8 %simulation results are available. Therefore, the results from simulation will be compared to the %CORE SIM+ results and discrete ordinate results.
%
%\subsection{2D BIBLIS Benchmark}
%Forward, Noise, ZPRTF, comparison
%
%\subsection{2D VVER-400 Benchmark}
%Forward, Noise, ZPRTF, comparison
%
%\subsection{3D Generic PWR}
%Forward, Noise, ZPRTF, comparison
%
%\subsection{3D VVER-400 Benchmark}
%Forward, Noise, ZPRTF, comparison
%
%\section{HTTR Benchmark}
%\label{sec:httr_benchmark}
%transport code \texttt{MCNP} is used to generate the test cases. The neutron transport code %\texttt{MCNP} is used to generate the test cases. The neutron transport code \texttt{MCNP} is %used to generate the test cases. The neutron transport code \texttt{MCNP} is used to generate %the test cases. The neutron transport code \texttt{MCNP} is used to generate the test cases. The %neutron transport code \texttt{MCNP} is used to generate the test cases. The neutron transport %code \texttt{MCNP} is used to generate the test cases. The neutron transport code \texttt{MCNP} %is used to generate the test cases.
%
%\subsection{2D HTTR Simulations}
%Forward, noise, ZPRTF, comparison
%
%\subsection{3D HTTR Simulations}
%Forward, noise, ZPRTF, comparison
%
%\section{Conclusions}